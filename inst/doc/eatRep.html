<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Sebastian Weirich and Benjamin Becker" />


<title>Replication analyses with eatRep</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Replication analyses with eatRep</h1>
<h4 class="author">Sebastian Weirich and Benjamin Becker</h4>
<h4 class="date">Jan 2025</h4>



<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>The following vignette demonstrates some analyses based on
replication methods <span class="citation">(Krewski &amp; Rao, 1981;
Rust, 2014; Rust &amp; Rao, 1996; Wolter, 2007)</span>. Replication
methods are quite common in the context of survey or large-scale
assessment data <span class="citation">(Foy et al., 2008)</span> like
the <a href="https://www.iqb.hu-berlin.de/bt">“National Assessment
Studies and IQB Trends in Student Achievement”</a> . The following
examples are closely related to the “IQB” context (e.g., jackknife-2
methods are used instead of balanced repeated replicates), but may be
adapted for PISA or TIMSS analyses as well. For an illustration how
<code>eatRep</code> can be applied to PISA data and its specific
replication design, see the last example in the documentation of the
<code>repMean()</code> function.</p>
<p>Please note that the theoretical foundations of the presented methods
are beyond the scope of this vignette—literature recommendations for in
depth theoretical discussions can be found in the package documentation
(type <code>package?eatRep</code> into the console). Instead, this
vignette focuses on some prototypical analyses.</p>
<p>Furthermore, note that IRT item calibration or “plausible values”
imputation are not covered in this vignette. All the outlined analyses
base on survey data in which “plausible values” are already included.
Such kind of data is provided by the <a href="https://webfs.oecd.org/pisa/">OECD</a> or can be requested from
the <a href="https://www.iqb.hu-berlin.de/fdz">“Research Data Centre
(FDZ) at the IQB”</a>. Most of the analyses comprise of descriptive
statistics (means, standard deviations), frequency distributions, and
linear or logistic regression models. Usually, sampling designs for
large-scale assessments have the following, specific
characteristics:</p>
<ol style="list-style-type: decimal">
<li><p>Often, individuals in survey data are not randomly drawn from the
population. In educational assessments which aim to compare countries,
for example, the proportions in the sample do not necessarily correspond
to the proportions in the population. Often, institutions like the OECD
provide sampling weights according with their data which allow to
estimate population parameters.</p></li>
<li><p>The (primary) sampling units in educational data are classes
instead of individuals. Hence, the sample is clustered. Students within
a class are more alike than students from different classes. Therefore,
clustered sampled students are more homogeneous than randomly sampled
students which may lead to biased standard error estimates in
inference-based analyses.</p></li>
<li><p>Variables of interest (e.g. educational achievement) are latent
and not directly observable (they are inherently missing). Additionally,
questionnaire data frequently include missing responses. Therefore,
institutions like the OECD or the IQB provide imputed data.</p></li>
</ol>
<p><code>eatRep</code> allows to compute (adjusted) means and mean
differences, frequency tables, percentiles, and parameter of (log)
linear regression models, taking the clustered and/or imputed sample
into account via replication methods. Trend analyses are possible as
well. <code>eatRep</code> meets the special features mentioned above (if
they apply) in the following way:</p>
<p>1.: include sampling weights for the analyses.</p>
<p>2.: Use replication methods (Bootstrap, jackknife or “Balanced
repeated replicates”) for inference statistics.</p>
<p>3.: Pool the results by applying specific rules <span class="citation">(Little &amp; Rubin, 1987; Rubin, 2003)</span>.</p>
<p>However, <code>eatRep</code> is also suitable if the data is
clustered without imputations or imputed without clustered sampling. The
three mentioned methods (using weights, replication methods, pooling
methods) can be called independently from each other.</p>
</div>
<div id="installation" class="section level2">
<h2>0. Installation</h2>
<p>We recommend to use R version 4.0.0 or higher. <code>eatRep</code> is
available from CRAN:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&quot;eatRep&quot;</span>)</span></code></pre></div>
</div>
<div id="example-data" class="section level2">
<h2>1. Example data</h2>
<p><code>eatRep</code> contains exemplary data named <code>lsa</code>
(“large scale assessment”), which resembles the “IQB
Gesamtanalysedatensatz (GADS)”. <code>lsa</code>, however, is reduced in
numbers of examinees, imputations, and variables. Once the package is
loaded, the structure of <code>lsa</code> can be inspected via:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(eatRep)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">data</span>(lsa, <span class="at">package=</span><span class="st">&quot;eatRep&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a><span class="fu">str</span>(lsa, <span class="at">give.attr =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    77322 obs. of  25 variables:
##  $ year     : num  2010 2010 2010 2010 2010 2010 2010 2010 2010 2010 ...
##  $ idstud   : Factor w/ 11655 levels &quot;P00001&quot;,&quot;P00002&quot;,..: 1 1 1 1 1 1 2 2 2 2 ...
##  $ idclass  : Factor w/ 432 levels &quot;C001&quot;,&quot;C002&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ wgt      : num  2.6 2.6 2.6 2.6 2.6 ...
##  $ L2wgt    : num  2.43 2.43 2.43 2.43 2.43 ...
##  $ L1wgt    : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ jkzone   : num  22 22 22 22 22 22 22 22 22 22 ...
##  $ jkrep    : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ imp      : num  3 2 1 1 2 3 2 3 2 1 ...
##  $ nest     : num  1 2 2 1 1 2 2 2 1 2 ...
##  $ country  : Factor w/ 3 levels &quot;countryA&quot;,&quot;countryB&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
##  $ sex      : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 2 2 2 2 2 2 2 2 2 ...
##  $ ses      : num  56 56 56 56 56 56 32.5 32.5 32.5 32.5 ...
##  $ mig      : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...
##  $ domain   : Factor w/ 2 levels &quot;listening&quot;,&quot;reading&quot;: 1 1 1 1 1 1 2 2 2 2 ...
##  $ score    : num  366 366 425 551 485 ...
##  $ comp     : num  1 1 2 3 3 3 3 3 3 3 ...
##  $ failMin  : num  1 1 0 0 0 0 0 0 0 0 ...
##  $ passReg  : num  0 0 0 1 1 1 1 1 1 1 ...
##  $ passOpt  : num  0 0 0 0 0 0 0 0 0 0 ...
##  $ leScore  : num  1.22 1.22 1.22 1.22 1.22 ...
##  $ leComp   : num  0.00262 0.00262 0.0022 0.00155 0.00155 ...
##  $ leFailMin: num  0.00262 0.00262 0.00262 0.00262 0.00262 ...
##  $ lePassReg: num  0.00482 0.00482 0.00482 0.00482 0.00482 ...
##  $ lePassOpt: num  0.00059 0.00059 0.00059 0.00059 0.00059 ...</code></pre>
<p><code>lsa</code> is in the long format; this means the data set
contains multiple rows per individual person. Imputed variables (e.g.,
migration background, <code>mig</code>) <em>do not</em> occur in several
columns (<code>mig_Imp_1</code>, <code>mig_Imp_2</code>,
<code>mig_Imp_3</code>, and so on), but only once: <code>mig</code>.
Multiple imputations are stored in multiple rows, and the variable
<code>imp</code> yields the number of the imputed data set. Furthermore,
variables which refer to different competence domains (reading,
listening) <em>and</em> different imputations <em>and</em> different
times of measurement (i.e., the competence variable <code>score</code>)
do not occur in multiple columns (<code>reading_2010_score_Imp_1</code>,
<code>reading_2010_score_Imp_2</code>, …,
<code>listening_2010_score_Imp_1</code>,
<code>listening_2015_score_Imp_1</code>, …). <code>score</code> only
occurs once, and <code>imp</code> defines the imputation, whereas
<code>domain</code> gives the competence domain. To reshape data between
the long and wide format, see for example the package <code>tidyr</code>
(<code>pivot_wider()</code>, <code>pivot_longer()</code>) or the
function <code>wideToLong()</code> from the package
<code>eatTools</code>. See section 1.1 for more details about reshaping
and examples.</p>
<p><code>lsa</code> contains the following variables:</p>
<ul>
<li><code>year</code>: year of assessment (2010 or 2015)</li>
<li><code>idstud</code>: individual student identifier; the data set
contains 11,637 persons overall</li>
<li><code>idclass</code>: class identifier; the data set contains 432
classes overall</li>
<li><code>wgt</code>: sampling weight</li>
<li><code>jkzone</code>: jackknife zone</li>
<li><code>jkrep</code>: jackknife replicate</li>
<li><code>imp</code>: number of imputation (1, 2, or 3)</li>
<li><code>nest</code>: number of nest (for nested imputation which is
not yet considered here, but see the examples of <code>repMean()</code>
for further details)</li>
<li><code>country</code>: federal state the student stems from</li>
<li><code>sex</code>: students sex (male, female)</li>
<li><code>ses</code>: socio economical status</li>
<li><code>mig</code>: migration background</li>
<li><code>domain</code>: competence domain (listening or reading)</li>
<li><code>score</code>: point estimate (e.g., plausible value) for the
corresponding imputation and domain. According to PISA, the scale is
normed with a mean of 500 and a standard deviation of 100</li>
<li><code>comp</code>: competence level with 5 distinct levels according
to pre-defined cut scores. “1” corresponds to the lowest competence
level, and “5” corresponds to the highest competence level</li>
<li><code>failMin</code>: does the student fail to achieve the minimum
standard?</li>
<li><code>passReg</code>: does the student achieve regular
standard?</li>
<li><code>passOpt</code>: does the student achieve optimal
standard?</li>
<li><code>leScore</code>: linking error according to <code>score</code>
variable</li>
<li><code>leComp</code>: linking error according to <code>comp</code>
variable</li>
<li><code>leFailMin</code>: linking error according to
<code>failMin</code> variable</li>
<li><code>lePassReg</code>: linking error according to
<code>passReg</code> variable</li>
<li><code>lePassOpt</code>: linking error according to
<code>passOpt</code> variable</li>
</ul>
<p><code>lsa</code> includes more than 77,000 observations. Actual large
scale assessment data, however, have much more observations.
<code>lsa</code> only represents a small section with only 3 imputations
(instead of 10 used in PISA), 3 federal states (PISA includes 35 OECD
countries), and two domains. Most variables have labels, stored as
attributes:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">attributes</span>(lsa[,<span class="st">&quot;year&quot;</span>])</span></code></pre></div>
<pre><code>## $varLabel
## [1] &quot;year of assessment (2010 or 2015)&quot;</code></pre>
<p>As nested imputations are not considered here, we reduce the data to
the first nest:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>bt <span class="ot">&lt;-</span> lsa[<span class="fu">which</span>(lsa[,<span class="st">&quot;nest&quot;</span>] <span class="sc">==</span> <span class="dv">1</span>),]</span></code></pre></div>
<div id="excursus-reshape-imputed-data-from-wide-into-long-format" class="section level3">
<h3>1.1 Excursus: reshape imputed data from wide into long format</h3>
<p>Institutions like PISA provide imputed data in the wide format. Each
row in the data matrix represents one person. <code>eatRep</code>,
however, needs the long format. (Without imputations, this procedure is
not necessary.) Wide format data stores different imputations of the
same variable in different columns. The number of imputations is not
stored in an explicit variable but results from the number of additional
columns per variable. Long format data stores different imputations of
the same variable in additional rows. A variable like <code>imp</code>
defines the number of the imputation.</p>
<p><code>reshape2</code>, <code>tidyr</code> or <code>data.table</code>
provide functions for reshaping. Moreover, <code>eatTools</code>
provides the <code>wideToLong()</code> function for easy reshaping into
the required long format. We illustrate the functionality with the help
of the wide format exemplary data <code>data.timss3</code> from the
<code>BIFIEsurvey</code> package:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">data</span>(data.timss3, <span class="at">package=</span><span class="st">&quot;BIFIEsurvey&quot;</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">str</span>(data.timss3, <span class="at">give.attr =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## &#39;data.frame&#39;:    4668 obs. of  20 variables:
##  $ IDSTUD : num  4e+08 4e+08 4e+08 4e+08 4e+08 ...
##  $ TOTWGT : num  17.5 17.5 17.5 17.5 17.5 ...
##  $ JKZONE : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ JKREP  : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ female : num  1 0 1 1 1 1 1 1 0 0 ...
##  $ books  : num  3 3 5 3 3 2 4 3 3 4 ...
##  $ lang   : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ migrant: num  0 0 0 0 0 0 0 0 0 0 ...
##  $ scsci  : num  NA 2 2 1 2 3 2 2 1 1 ...
##  $ likesc : num  2 4 2 1 1 1 2 2 NA 1 ...
##  $ ASMMAT1: num  543 522 456 512 506 ...
##  $ ASSSCI1: num  600 512 497 584 533 ...
##  $ ASMMAT2: num  557 533 462 510 563 ...
##  $ ASSSCI2: num  578 519 545 614 568 ...
##  $ ASMMAT3: num  506 557 445 531 530 ...
##  $ ASSSCI3: num  570 554 528 569 564 ...
##  $ ASMMAT4: num  524 511 473 497 488 ...
##  $ ASSSCI4: num  560 506 550 597 483 ...
##  $ ASMMAT5: num  578 546 457 528 583 ...
##  $ ASSSCI5: num  607 565 546 623 578 ...</code></pre>
<p>Data contains 4668 rows according to 4668 persons. The following
variables should be considered for reshaping:</p>
<ul>
<li><code>IDSTUD</code>: individual student identifier</li>
<li><code>TOTWGT</code>: weighting variable</li>
<li><code>JKZONE</code>: jackknife zone</li>
<li><code>JKREP</code>: jackknife replicate</li>
<li><code>female</code>: students sex (1 = female; 0 = male)</li>
<li><code>books</code>: number of books at home</li>
<li><code>lang</code>: language at home (How often is the language used
in the test spoken at home?)</li>
<li><code>migrant</code>: migration background</li>
<li><code>ASMMAT1</code>: first imputation (first plausible value) for
math competence</li>
<li><code>ASMMAT2</code>: second imputation (second plausible value) for
math competence</li>
<li><code>ASMMAT3</code>: third imputation (third plausible value) for
math competence</li>
<li><code>ASMMAT4</code>: fourth imputation (fourth plausible value) for
math competence</li>
<li><code>ASMMAT5</code>: fifth imputation (fifth plausible value) for
math competence</li>
<li><code>ASSSCI1</code>: first imputation (first plausible value) for
science competence</li>
<li><code>ASSSCI2</code>: second imputation (second plausible value) for
science competence</li>
<li><code>ASSSCI3</code>: third imputation (third plausible value) for
science competence</li>
<li><code>ASSSCI4</code>: fourth imputation (fourth plausible value) for
science competence</li>
<li><code>ASSSCI5</code>: fifth imputation (fifth plausible value) for
science competence</li>
</ul>
<p>As TIMSS data is in the wide format, no imputation variable exists.
In contrast to the long format, we can easily see which variables are
imputed (<code>ASMMAT</code> occurs five times), and which are not
(<code>female</code> only occurs once). For reshaping, number of
imputations must be constant across imputed variables—hence,
<code>wideToLong()</code> cannot be used for nested imputed data.
<code>wideToLong()</code> needs to know all variables which should be
used for further analyses—the remaining variables can be ignored. The
functionality differentiates between imputed and non-imputed
variables:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">library</span>(eatTools)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>timssLong <span class="ot">&lt;-</span> eatTools<span class="sc">::</span><span class="fu">wideToLong</span>(<span class="at">datWide =</span> data.timss3, </span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>             <span class="at">noImp =</span> <span class="fu">c</span>(<span class="st">&quot;IDSTUD&quot;</span>, <span class="st">&quot;TOTWGT&quot;</span>, <span class="st">&quot;JKZONE&quot;</span>, <span class="st">&quot;JKREP&quot;</span>, <span class="st">&quot;female&quot;</span>), </span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>             <span class="at">imp =</span> <span class="fu">list</span> ( <span class="at">math =</span> <span class="fu">c</span>(<span class="st">&quot;ASMMAT1&quot;</span>, <span class="st">&quot;ASMMAT2&quot;</span>, <span class="st">&quot;ASMMAT3&quot;</span>, <span class="st">&quot;ASMMAT4&quot;</span>, <span class="st">&quot;ASMMAT5&quot;</span>), </span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>                       <span class="at">science =</span> <span class="fu">c</span>(<span class="st">&quot;ASSSCI1&quot;</span>, <span class="st">&quot;ASSSCI2&quot;</span>, <span class="st">&quot;ASSSCI3&quot;</span>, <span class="st">&quot;ASSSCI4&quot;</span>, <span class="st">&quot;ASSSCI5&quot;</span>)))</span></code></pre></div>
<p>The non-imputed variables can be defined in a single character
string, whereas imputed variables should be defined in a named list with
one or more character strings. In our example, variable
<code>math</code> consists of five imputations <code>ASMMAT1</code>,
<code>ASMMAT2</code>, <code>ASMMAT3</code>, <code>ASMMAT4</code>, and
<code>ASMMAT5</code>. Variable <code>science</code> also consists of
five imputations, <code>ASSSCI1</code>, <code>ASSSCI2</code>,
<code>ASSSCI3</code>, <code>ASSSCI4</code>, and <code>ASSSCI5</code>.
Resulting data <code>timssLong</code> now is suitable for
<code>eatRep</code> analyses. For many imputations (e.g., 15),
specifying character strings is more straightforward by using the
<code>paste()</code> or <code>paste0()</code> function:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>timssLong <span class="ot">&lt;-</span> eatTools<span class="sc">::</span><span class="fu">wideToLong</span>(<span class="at">datWide =</span> data.timss3, </span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>             <span class="at">noImp =</span> <span class="fu">c</span>(<span class="st">&quot;IDSTUD&quot;</span>, <span class="st">&quot;TOTWGT&quot;</span>, <span class="st">&quot;JKZONE&quot;</span>, <span class="st">&quot;JKREP&quot;</span>, <span class="st">&quot;female&quot;</span>), </span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>             <span class="at">imp =</span> <span class="fu">list</span> ( <span class="at">math =</span> <span class="fu">paste0</span>(<span class="st">&quot;ASMMAT&quot;</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>),  </span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>                       <span class="at">science =</span> <span class="fu">paste0</span>(<span class="st">&quot;ASSSCI&quot;</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)))</span></code></pre></div>
<p>Alternatively, reshaping can be performed with <code>melt()</code>
from the <code>data.table</code> package:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">library</span>(data.table)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>timssLong2<span class="ot">&lt;-</span> data.table<span class="sc">::</span><span class="fu">melt</span>(<span class="fu">setDT</span>(data.timss3), </span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>                <span class="at">id =</span> <span class="fu">c</span>(<span class="st">&quot;IDSTUD&quot;</span>, <span class="st">&quot;TOTWGT&quot;</span>, <span class="st">&quot;JKZONE&quot;</span>, <span class="st">&quot;JKREP&quot;</span>, <span class="st">&quot;female&quot;</span>), </span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>                <span class="at">measure =</span> <span class="fu">patterns</span>(<span class="st">&quot;^ASMMAT&quot;</span>, <span class="st">&quot;^ASSSCI&quot;</span>), </span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>                <span class="at">value.name =</span> <span class="fu">c</span>(<span class="st">&quot;math&quot;</span>, <span class="st">&quot;science&quot;</span>), <span class="at">variable.name=</span><span class="st">&quot;imp&quot;</span>)</span></code></pre></div>
</div>
</div>
<div id="main-functions-of-eatrep" class="section level2">
<h2>2. Main functions of “eatRep”</h2>
<p>The four main functions can be seen as “replication variants” of the
base <code>R</code> functions <code>mean()</code>, <code>table()</code>,
<code>quantile()</code>, and <code>glm()</code>:</p>
<ol style="list-style-type: decimal">
<li><p><code>repMean()</code>: computes means, standard deviations, mean
differences, and standard deviation differences</p></li>
<li><p><code>repTable()</code>: computes frequency tables and
differences thereof</p></li>
<li><p><code>repQuantile()</code> for quantiles, percentiles, and so
on</p></li>
<li><p><code>repGlm()</code>: linear and generalized linear regression
models</p></li>
</ol>
<div id="mean-analysis" class="section level3">
<h3>2.1 Mean analysis</h3>
<p>For the first example, we want to compute means and standard
deviations (along with their standard errors) in reading competencies
for several federal states at one distinct time of measurement (2010).
As <code>bt</code> contains data from 2010 and 2015 as well as both
competencies reading and listening, we subset the data set:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>bt2010     <span class="ot">&lt;-</span> bt[<span class="fu">which</span>(bt[,<span class="st">&quot;year&quot;</span>] <span class="sc">==</span> <span class="dv">2010</span>),]</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>bt2010read <span class="ot">&lt;-</span> bt2010[<span class="fu">which</span>(bt2010[,<span class="st">&quot;domain&quot;</span>] <span class="sc">==</span> <span class="st">&quot;reading&quot;</span>),]</span></code></pre></div>
<p>We now call <code>repMean()</code> with the reduced data set
<code>bt2010read</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="st">&quot;country&quot;</span>, <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, </span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>           <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<p>We use <code>country</code> as a grouping variable—all analyses are
computed for each country separately. Important: persons in the data
must be nested within the grouping variable. This is true for
<code>country</code>; each person belongs to only one federal state. For
another possible grouping variable, <code>domain</code>, this is not the
case, as one single person may have worked on items from more than one
domain. To check whether persons are nested within a grouping variable,
the function <code>isNested()</code> from the <code>lme4</code> package
package can be called:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>lme4<span class="sc">::</span><span class="fu">isNested</span>(bt2010[,<span class="st">&quot;idstud&quot;</span>], bt2010[,<span class="st">&quot;country&quot;</span>])</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>lme4<span class="sc">::</span><span class="fu">isNested</span>(bt2010[,<span class="st">&quot;idstud&quot;</span>], bt2010[,<span class="st">&quot;domain&quot;</span>])</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>To conduct the analyses for both domains in a single call, we
recommend using a loop, according to “listening” and “reading”. We
demonstrate this usage in section 2.5. To collect the results in a
single <code>data.frame</code> which can be exported to excel, for
example, the reporting function <code>report2()</code> should be
called.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>resReading <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>To simplify the graphical visualization of the results using the <a href="https://nickhaf.github.io/eatPlot/">eatPlot</a> package, a new
reporting function called <code>report2()</code> was introduced. If you
are only interested in a tabular representation of the results, it is
sufficient to simply extract the “plain” worksheet from the list object
returned by the function. The old reporting function is still included
in the package but deprecated. The argument <code>add</code> augments
the output with additional columns. The function does not know that the
analysis is about “reading” competence. If this information should be
incorporated in the output, the <code>add</code> argument allows to
define one or multiple additional columns with scalar information of
character type, for example:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>resReading <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb=</span><span class="st">&quot;reading&quot;</span>, <span class="at">year =</span> <span class="st">&quot;2010&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>The analysis above includes one grouping variable (“country”) and one
competence domain (“reading”) without any group comparisons. The output
therefore is rather sparse.</p>
<p>However, the results can be computed according to more than one
grouping variable. If the results should be computed for each country
and each migration group, both are specified as grouping variables:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;mig&quot;</span>), <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, </span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a>           <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>Frequently, one might not only be interested in group means but also
the total mean. Hence, we want to know the mean of each single country
<em>and</em> the mean of the whole population. You can repeat the
analysis two times, one including grouping variables and one ignoring
all grouping variables, but it is easier to use only one single
call:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="st">&quot;country&quot;</span>, <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, </span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>           <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 2 analyse(s) overall according to: &#39;group.splits = 0 1&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                     NA
##                2               1           country                   NA
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>The argument Argument <code>group.splits</code> defines “hierarchy
levels” for the analyses, indicating whether the analysis should be
conducted within or across groups. The number of hierarchy levels always
equals the number of grouping variables plus one. One grouping variable
means two hierarchy levels, two grouping variables mean three levels,
and so on. Without any grouping variables, only one level, the “zeroth”
level, exists. At the zeroth level, no differentiation takes place; all
statistics are computed for the whole population. With one grouping
variable (<code>country</code>, for example) two levels can be defined:
at the zeroth level, statistics are computed for the whole population,
and at the first level, statistics are computed for
<code>countryA</code>, <code>countryB</code>, and <code>countryC</code>
separately. With two grouping variables (<code>country</code> and
migration background: <code>mig</code>), three hierarchy levels are
defined. The entire group (zeroth level), statistics computed for
<code>countryA</code>, <code>countryB</code>, and <code>countryC</code>
(first level, according to <code>country</code>), statistics computed
for <code>no migration background</code> and
<code>migration background</code> (first level, according to
<code>mig</code>), and at the second level, statistics separately
computed for migrants in <code>countryA</code>, migrants in
<code>countryB</code>, migrants in <code>countryB</code>, natives in
<code>countryA</code>, natives in <code>countryB</code>, natives in
<code>countryC</code>. <code>group.splits</code> is a numeric vector
which contains all desired hierarchy levels. Without specifying
<code>group.splits</code>, only the highest hierarchy level is
considered for analysis.</p>
<p>Assume only one grouping variable. <code>group.splits = c(0,1)</code>
or <code>group.splits = 0:1</code> additionally computes statistics for
the zeroth level. For two grouping variables,
<code>group.splits = 1:2</code> computes statistics for the first and
second level. The zeroth level is omitted. To yield statistics for all
possible level, type <code>group.splits = 0:x</code>, where “x” equals
the number of grouping variables.</p>
</div>
<div id="group-differences-in-means" class="section level3">
<h3>2.2 Group differences in means</h3>
<p>Do boys and girls significantly differ in their mean competencies? Do
Bavarian students outperform Saxonian students in “reading”? Is the mean
score of Canadian students significantly above the OECD average? These
examples can be distinguished regarding whether both units, which should
be compared, share the same hierarchy level. Differences within a
hierarchy level (e.g., boys vs. girls) are referred to as “group
differences”. Differences between (adjacent) hierarchy levels (e.g.,
Canadian vs. OECD average, as Canada itself is part of the OECD average)
are referred to as “cross-level differences”. The following example
deals with group differences according to <code>sex</code>—we compare,
whether boys and girls significantly differ in their means:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, </span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>           <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>The argument <code>group.differences.by</code> defines the grouping
variable for which differences should be computed. Note that only one
variable can be specified in <code>group.differences.by</code>, and this
variable must also occur in <code>groups</code> (which may, however,
contain further variables). All pairwise contrasts are computed for the
levels in the <code>group.differences.by</code>-variable. If the
grouping variable is dichotomous with two levels (boys, girls), only one
contrast (boys vs. girls) can be defined. If the grouping variable is
polytomous with three levels (for example, <code>country</code> with
countryA, countryB, countryC), three contrasts will be computed
(countryA vs. countryB, countryA vs. countryC, countryB vs. countryC). A
polytomous variable with four levels defines six contrasts, and so on.
If <code>groups</code> includes more than one variable,
<code>group.differences.by</code> defines for which of these variables
group differences should be computed. If sex differences should be
computed for each country separately, consider the following call:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), </span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>           <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>Compute sex differences in each country and additionally for the
whole group:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb33-2"><a href="#cb33-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">2</span>, </span>
<span id="cb33-3"><a href="#cb33-3" tabindex="-1"></a>           <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country                 &lt;NA&gt;
##                3               1               sex                  sex
##                4               2     country + sex                  sex
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>Compute country differences within each sex group and additionally
for the whole group:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">2</span>, </span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>           <span class="at">group.differences.by =</span> <span class="st">&quot;country&quot;</span>, <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
</div>
<div id="cross-level-differences-in-means" class="section level3">
<h3>2.3 cross-level differences in means</h3>
<p>For the easiest case, assume only one grouping variable
(<code>sex</code> with levels <code>boys</code> and <code>girls</code>)
and two hierarchy levels—the zeroth and the first level. Cross-level
differences then refer to the difference of one group mean (e.g.,
<code>boys</code> mean) and the total mean. With two or more grouping
variables, cross-level differences can be thought of differences of one
distinct group with all higher-ranking hierarchy levels. Assuming two
grouping variables (<code>country</code> with three levels, and
migration background <code>mig</code> with two levels), 23 cross-level
differences are theoretically possible:</p>
<p><strong>level 2 vs. level 1:</strong></p>
<ul>
<li>migrants in countryA vs. migrants</li>
<li>migrants in countryB vs. migrants</li>
<li>migrants in countryC vs. migrants</li>
<li>natives in countryA vs. natives</li>
<li>natives in countryB vs. natives</li>
<li>natives in countryC vs. natives</li>
<li>migrants in countryA vs. countryA</li>
<li>migrants in countryB vs. countryB</li>
<li>migrants in countryC vs. countryC</li>
<li>natives in countryA vs. countryA</li>
<li>natives in countryB vs. countryB</li>
<li>natives in countryC vs. countryC</li>
</ul>
<p><strong>level 1 vs. level 0:</strong></p>
<ul>
<li>migrants vs. whole population</li>
<li>natives vs. whole population</li>
<li>countryA vs. whole population</li>
<li>countryB vs. whole population</li>
<li>countryC vs. whole population</li>
</ul>
<p><strong>level 2 vs. level 0:</strong></p>
<ul>
<li>migrants in countryA vs. whole population</li>
<li>migrants in countryB vs. whole population</li>
<li>migrants in countryC vs. whole population</li>
<li>natives in countryA vs. whole population</li>
<li>natives in countryB vs. whole population</li>
<li>natives in countryC vs. whole population</li>
</ul>
<p>Each cross-level difference “connects” two hierarchy levels.
Hierarchy levels are neighboring, if their difference equals 1. Levels 2
and 1 are neighboring, but levels 2 and 0 are not. To compute
cross-level differences, <code>group.splits</code> must be specified as
a numeric vector of at least two distinct elements. To reduce number of
cross-level differences, the argument <code>cross.differences</code>
allows to define for which pairs of hierarchy levels cross-level
differences should be computed.</p>
<p>To give an example: Consider both grouping variables
<code>country</code> (3 levels) and <code>mig</code> (2 levels). Means
should be computed for each of the three hierarchy levels. Group
differences should be computed for the <code>country</code> variable
(e.g., countryA vs. countryB, countryA vs. countryC, and countryB
vs. countryC). Cross-level differences should be computed only in
relation to the zeroth level, e.g. level 1 vs. level 0, and level 2
vs. level 0. The following command should be called:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">2</span>, </span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a>           <span class="at">group.differences.by =</span> <span class="st">&quot;country&quot;</span>, <span class="at">cross.differences =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span>)), </span>
<span id="cb39-4"><a href="#cb39-4" tabindex="-1"></a>           <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## Warning in repMeanList(datL = datL, a = a): Computation of cross level differences using &#39;wec&#39; method is only possible for differences according to adjacent levels. Non-adjacent levels will be ignored.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.</code></pre>
<p><code>cross.differences</code> requests a list of numeric vectors
with distinct elements each. Each vector must consist of two integers,
specifying the hierarchy levels for which cross-differences should be
computed. For simplicity, <code>cross.differences = TRUE</code> requests
all possible cross-level differences. Conversely,
<code>cross.differences = FALSE</code> omits all cross-level
differences.</p>
<p>Combining <code>group.differences.by</code> and
<code>cross.differences</code> allows to compute cross-level differences
of group differences, for example, if researchers want to know whether
the difference “boys vs. girls” in “countryA” differs from the
difference “boys vs. girls” in the total population. Note that we
explicitly assume heteroscedastic variance in cross-level difference
estimation by setting <code>hetero = TRUE</code> and
<code>clusters = &quot;idclass&quot;</code>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb43-1"><a href="#cb43-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb43-2"><a href="#cb43-2" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">2</span>, </span>
<span id="cb43-3"><a href="#cb43-3" tabindex="-1"></a>           <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">cross.differences =</span> <span class="cn">TRUE</span>, <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, </span>
<span id="cb43-4"><a href="#cb43-4" tabindex="-1"></a>           <span class="at">progress =</span> <span class="cn">FALSE</span>, <span class="at">clusters =</span> <span class="st">&quot;idclass&quot;</span>, <span class="at">hetero =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country                 &lt;NA&gt;
##                3               1               sex                  sex
##                4               2     country + sex                  sex
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## Compute cross level differences using &#39;wec&#39; method. Assume heteroscedastic variances.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 32 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 60 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 40 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 91 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.</code></pre>
<p>In the output data.frame created by <code>report2()</code>,
cross-level differences of group differences are marked with the entry
<code>crossDiff_of_groupDiff</code> in the <code>comparison</code>
column.</p>
</div>
<div id="statistical-remarks" class="section level3">
<h3>2.4 Statistical remarks</h3>
<p>For cross-level differences, the groups are not independent—when
comparing <code>countryA</code> with the whole population, one must
consider that <code>countryA</code> is part of the whole population.
Hence, a <em>t</em> test is not appropriate. <code>eatRep</code>
supports “weighted effect coding” <span class="citation">(Grotenhuis et
al., 2017; Weirich et al., 2021)</span> or replication methods (e.g,
bootstrap), with “weighted effect coding” (wec) being the default.
Alternative methods can be chosen with the <code>crossDiffSE</code>
argument. The method <code>old</code> uses an inappropriate <em>t</em>
test and should not be used. The method is maintained in the package to
provide compatibility with older versions.</p>
</div>
<div id="trend-analyses" class="section level3">
<h3>2.5 Trend analyses</h3>
<p>In general, trends are just group differences. If the groups are
distinct, persons are nested within the trend variable (each person
belongs to solely one point in time). The major factor distinguishing
trends from “conventional” group differences is the item sample: For
group differences, the item sample is usually identical, for trends,
this is not necessarily the case. Moreover, comparisons across different
points in time run the risk of being affected by differential item
functioning (DIF) or item parameter drift (IPD). If DIF can be
considered as random, it should be incorporated into the computation of
standard errors of trend estimates. If standard error of trend estimates
should be computed, <code>eatRep</code> allows to take the “linking
error” according to differently functioning items into account.</p>
<p>When computing trends, the analysis is conducted in both cohorts (for
example, 2010 and 2015) separately. Afterwards, for each combination of
grouping variables, the difference <span class="math inline">\(\bar{m}_{2015}-\bar{m}_{2010}\)</span> is
estimated. The standard error of this difference is: <span class="math display">\[\begin{equation}
SE_{trend}=\sqrt{SE_{2010}^2+SE_{2015}^2+SE_{link}^2}.
\end{equation}\]</span></p>
<p>Trends can be computed for simple means, group differences, and
cross-level differences. For illustration the last analysis now will be
repeated with additional trend estimation. The former used data object
<code>bt2010read</code> cannot be used any longer as only 2010 data are
included. We use “reading competence” for 2010 and 2015 by subsetting
the <code>bt</code> data. In the function call, the trend variable
<code>trend = &quot;year&quot;</code> as well as the linking error
<code>linkErr = &quot;leScore&quot;</code> have to be defined. Without specifying
the <code>linkErr</code> argument, the linking error is defaulted to
0.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a>btread  <span class="ot">&lt;-</span> bt[<span class="fu">which</span>(bt[,<span class="st">&quot;domain&quot;</span>] <span class="sc">==</span> <span class="st">&quot;reading&quot;</span>),]</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> btread, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">2</span>, </span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a>           <span class="at">group.differences.by =</span> <span class="st">&quot;country&quot;</span>, <span class="at">cross.differences =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span>)), </span>
<span id="cb47-5"><a href="#cb47-5" tabindex="-1"></a>           <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">trend =</span> <span class="st">&quot;year&quot;</span>, <span class="at">linkErr =</span> <span class="st">&quot;leScore&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 
## Trend group: &#39;2010&#39;
## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## Warning in repMeanList(datL = datL, a = a): Computation of cross level differences using &#39;wec&#39; method is only possible for differences according to adjacent levels. Non-adjacent levels will be ignored.
## 
##
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
## Note: No linking error was defined. Linking error will be defaulted to &#39;0&#39;.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
## Note: No linking error was defined. Linking error will be defaulted to &#39;0&#39;.</code></pre>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a>res     <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]] </span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.</code></pre>
</div>
<div id="loops-across-non-nested-grouping-variables" class="section level3">
<h3>2.6 Loops across non-nested (grouping) variables</h3>
<p>Arguments <code>groups</code> and <code>group.splits</code> allow to
analyze different groups and different hierarchy levels with just one
single call. Alternatively, <code>repMean()</code> may be called two
times, once without grouping variable(s), and one with additional
grouping variable(s). The argument <code>groups</code> requires that
individuals are nested within grouping variables. Individuals, however,
are not nested within competence domains (“reading” and
“listening”)—<code>domain</code> cannot be used as grouping variable.
Alternatively, if both domains should be analyzed with one single call,
an additional outer loop is necessary. We demonstrate this procedure
with exemplary data <code>bt</code>, containing both domains “reading”
and “listening”. As in the example before, we analyze group,
cross-level, and trend differences.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">by</span>(<span class="at">data =</span> bt, <span class="at">INDICES =</span> bt[,<span class="st">&quot;domain&quot;</span>], <span class="at">FUN =</span> <span class="cf">function</span> ( subsample) {</span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a>           <span class="fu">repMean</span>(<span class="at">datL =</span> subsample, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb51-3"><a href="#cb51-3" tabindex="-1"></a>                    <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), </span>
<span id="cb51-4"><a href="#cb51-4" tabindex="-1"></a>                    <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">2</span>, <span class="at">group.differences.by =</span> <span class="st">&quot;country&quot;</span>, </span>
<span id="cb51-5"><a href="#cb51-5" tabindex="-1"></a>                    <span class="at">cross.differences =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">2</span>)), <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, </span>
<span id="cb51-6"><a href="#cb51-6" tabindex="-1"></a>                    <span class="at">trend =</span> <span class="st">&quot;year&quot;</span>, <span class="at">linkErr =</span> <span class="st">&quot;leScore&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>) } )</span></code></pre></div>
<pre><code>## 
## Trend group: &#39;2010&#39;
## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## Warning in repMeanList(datL = datL, a = a): Computation of cross level differences using &#39;wec&#39; method is only possible for differences according to adjacent levels. Non-adjacent levels will be ignored.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
## Note: No linking error was defined. Linking error will be defaulted to &#39;0&#39;.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
## Note: No linking error was defined. Linking error will be defaulted to &#39;0&#39;.
##
## 
## Trend group: &#39;2010&#39;
## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 4 analyse(s) overall according to: &#39;group.splits = 0 1 2&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by
##                1               0                                   &lt;NA&gt;
##                2               1           country              country
##                3               1               sex                 &lt;NA&gt;
##                4               2     country + sex              country
## 
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## Warning in repMeanList(datL = datL, a = a): Computation of cross level differences using &#39;wec&#39; method is only possible for differences according to adjacent levels. Non-adjacent levels will be ignored.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
## Note: No linking error was defined. Linking error will be defaulted to &#39;0&#39;.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
## Note: No linking error was defined. Linking error will be defaulted to &#39;0&#39;.</code></pre>
<p>The <code>by</code>-loop around <code>repMean</code> splits the data
in two subsets which are analyzed consecutively. The
<code>results</code> object is a list with two elements, “listening” and
“reading”. The reporting function must be called for these two list
elements separately. We now see that the argument <code>add</code> can
help to distinguish both resulting data.frames. First, the processing is
demonstrated without using a loop:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a><span class="fu">names</span>(results)</span></code></pre></div>
<pre><code>## [1] &quot;listening&quot; &quot;reading&quot;</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a>resultsListening <span class="ot">&lt;-</span> <span class="fu">report2</span>(results[[<span class="st">&quot;listening&quot;</span>]], <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb =</span> <span class="st">&quot;listening&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.</code></pre>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a>resultsReading   <span class="ot">&lt;-</span> <span class="fu">report2</span>(results[[<span class="st">&quot;reading&quot;</span>]], <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb =</span> <span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.</code></pre>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a>allResults1      <span class="ot">&lt;-</span> <span class="fu">rbind</span> (resultsListening, resultsReading)</span></code></pre></div>
<p>Using a loop shortens the call, especially if more than two
competence domains are used:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>allResults2      <span class="ot">&lt;-</span> <span class="fu">lapply</span>(<span class="fu">names</span>(results), <span class="at">FUN =</span> <span class="cf">function</span> ( x ) { </span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>                           <span class="fu">report2</span>(results[[x]], <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb=</span>x))[[<span class="st">&quot;plain&quot;</span>]]})</span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for &#39;crossDiff_of_groupDiff&#39; is currently not supported.
## Warning in FUN(X[[i]], ...): Standard error correction for crossDifferences across multiple hierarchy levels is currently not supported.</code></pre>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a>allResults2      <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, allResults2)</span></code></pre></div>
</div>
<div id="adjusted-means" class="section level3">
<h3>2.7 Adjusted means</h3>
<p><code>eatRep</code> also allows to compute “adjusted” means <span class="citation">(Mayer et al., 2016; Nachtigall et al., 2008)</span>.
We will not elaborate on theoretical issues about adjusted means—broadly
speaking, unadjusted comparisons between two countries, say, Japan and
Vietnam, may be difficult to interpret, because both countries differ
substantially in terms of mean socio-economical status, migration
background, and other background variables. Adjusted means can be
thought of as weighted means to answer the question: would both
countries still differ in their mean competencies, if the distribution
of background variables would be equal? The researcher is free to select
which background or demographic variables should be chosen for
adjustment.</p>
<p>We demonstrate the computation of adjusted means for the domain
“reading” in 2010, where we adjust for <code>sex</code>, migration
background (<code>mig</code>) and socio-economical status
(<code>ses</code>). All variables selected for adjustment must be
numeric. For polytomous variables (e.g., language at home: “german”,
“german and another language”, “only another language”) dichotomous
indicator variables must be generated beforehand. In the following
example, we transform the non-numeric adjustment variables
<code>sex</code> and <code>mig</code> to be numeric.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a><span class="fu">sapply</span>(bt2010read[,<span class="fu">c</span>(<span class="st">&quot;sex&quot;</span>, <span class="st">&quot;mig&quot;</span>, <span class="st">&quot;ses&quot;</span>)], class) </span></code></pre></div>
<pre><code>##       sex       mig       ses 
##  &quot;factor&quot; &quot;logical&quot; &quot;numeric&quot;</code></pre>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a>bt2010read[,<span class="st">&quot;sexnum&quot;</span>] <span class="ot">&lt;-</span> car<span class="sc">::</span><span class="fu">recode</span>(bt2010read[,<span class="st">&quot;sex&quot;</span>], <span class="st">&quot;&#39;male&#39;=0; &#39;female&#39;=1&quot;</span>, </span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a>                         <span class="at">as.factor =</span> <span class="cn">FALSE</span>)</span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a>bt2010read[,<span class="st">&quot;mignum&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(bt2010read[,<span class="st">&quot;mig&quot;</span>])</span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a>           <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="st">&quot;country&quot;</span>, <span class="at">group.splits =</span> <span class="dv">0</span><span class="sc">:</span><span class="dv">1</span>, </span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a>           <span class="at">cross.differences =</span> <span class="cn">TRUE</span>, <span class="at">adjust =</span> <span class="fu">c</span>(<span class="st">&quot;sexnum&quot;</span>, <span class="st">&quot;mignum&quot;</span>, <span class="st">&quot;ses&quot;</span>), </span>
<span id="cb65-7"><a href="#cb65-7" tabindex="-1"></a>           <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## Warning in repMeanList(datL = datL, a = a): To date, for adjusted means, cross-level differences can only be computed with method &#39;old&#39;. Set &#39;crossDiffSE&#39; to &#39;old&#39;.
## 2 analyse(s) overall according to: &#39;group.splits = 0 1&#39;.
##  
##  analysis.number hierarchy.level groups.divided.by group.differences.by adjust
##                1               0                                     NA  FALSE
##                2               1           country                   NA   TRUE
## 
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a>res <span class="ot">&lt;-</span> <span class="fu">report2</span>(results, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>Please note that, to date, cross-level differences for adjusted means
can only be computed using the methods <code>old</code>. In the zeroth
hierarchy level, no adjustment takes place. As the distribution of
background variables in the total population is used as the reference
for the adjusted group means, the adjusted population mean is equal to
the unadjusted population mean.</p>
<p>If trends should be computed for adjusted means, the procedure
sketched above cannot be adopted without further ado. If the adjusted
mean of <code>countryA</code> in 2015 should be compared with the
adjusted mean of <code>countryA</code> in 2010, the reference group is
no longer the total population (e.g., all countries). Unadjusted means
do no depend on the specific research questions, but for adjusted means,
the research questions matters: Does <code>countryA</code> in 2015
differ from <code>countryB</code> in 2015? Or does <code>countryA</code>
in 2010 differ from <code>countryA</code> in 2015? Both questions
require different adjustment approaches.</p>
<p>In the previous section, the adjustment for only one time of
measurement was sketched: Would Japan still differ from Vietnam, if the
distribution of background variables were equivalent? For trend
analyses, the research question could be: Would there be differences
between 2010 and 2015 for Japan, if the composition of students
according to some demographic variables would not have changed? The
package <code>eatRep</code> does not differentiate between both types of
research questions. To compute adjusted trends, the formerly known trend
variable <code>year</code> must be used as grouping variable. If
adjusted trends for different groups should be estimated, the subsetting
according to groups must be done by hand or via an outer loop. The
incorporation of linking errors, if desired, must be done by hand
likewise. The following example illustrates the procedure. The standard
error of the trend estimate is computed as the square root of the sum of
the squared standard errors for 2010, 2015 and the link:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a>btread  <span class="ot">&lt;-</span> bt[<span class="fu">which</span>(bt[,<span class="st">&quot;domain&quot;</span>] <span class="sc">==</span> <span class="st">&quot;reading&quot;</span>),]</span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>btread[,<span class="st">&quot;sexnum&quot;</span>] <span class="ot">&lt;-</span> car<span class="sc">::</span><span class="fu">recode</span>(btread[,<span class="st">&quot;sex&quot;</span>], <span class="st">&quot;&#39;male&#39;=0; &#39;female&#39;=1&quot;</span>, <span class="at">as.factor =</span> <span class="cn">FALSE</span>)</span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a>btread[,<span class="st">&quot;mignum&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(btread[,<span class="st">&quot;mig&quot;</span>])</span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a>btread[,<span class="st">&quot;year&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(btread[,<span class="st">&quot;year&quot;</span>])</span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">by</span>(<span class="at">data =</span> btread,  <span class="at">INDICES =</span> btread[,<span class="st">&quot;country&quot;</span>], <span class="at">FUN =</span> <span class="cf">function</span>(sub.dat) {</span>
<span id="cb68-6"><a href="#cb68-6" tabindex="-1"></a>           res <span class="ot">&lt;-</span> <span class="fu">repMean</span>(<span class="at">datL =</span> sub.dat, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb68-7"><a href="#cb68-7" tabindex="-1"></a>                  <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;year&quot;</span>), </span>
<span id="cb68-8"><a href="#cb68-8" tabindex="-1"></a>                  <span class="at">adjust =</span> <span class="fu">c</span>(<span class="st">&quot;sexnum&quot;</span>, <span class="st">&quot;mignum&quot;</span>, <span class="st">&quot;ses&quot;</span>), <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>,</span>
<span id="cb68-9"><a href="#cb68-9" tabindex="-1"></a>                  <span class="at">progress =</span> <span class="cn">FALSE</span>)</span>
<span id="cb68-10"><a href="#cb68-10" tabindex="-1"></a>           res <span class="ot">&lt;-</span> <span class="fu">report2</span>(res, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb=</span><span class="st">&quot;reading&quot;</span>, </span>
<span id="cb68-11"><a href="#cb68-11" tabindex="-1"></a>                          <span class="at">country=</span> <span class="fu">as.character</span>(sub.dat[<span class="dv">1</span>,<span class="st">&quot;country&quot;</span>])))[[<span class="st">&quot;plain&quot;</span>]]</span>
<span id="cb68-12"><a href="#cb68-12" tabindex="-1"></a>           res[,<span class="st">&quot;trend&quot;</span>]   <span class="ot">&lt;-</span> <span class="fu">diff</span>(res[,<span class="st">&quot;est&quot;</span>])</span>
<span id="cb68-13"><a href="#cb68-13" tabindex="-1"></a>           res[,<span class="st">&quot;trendSE&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">sum</span>(res[,<span class="st">&quot;se&quot;</span>]<span class="sc">^</span><span class="dv">2</span>) <span class="sc">+</span> <span class="fu">unique</span>(sub.dat[,<span class="st">&quot;leScore&quot;</span>])<span class="sc">^</span><span class="dv">2</span>)</span>
<span id="cb68-14"><a href="#cb68-14" tabindex="-1"></a>           <span class="fu">return</span>(res)})</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 62 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 65 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 48 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb70"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb70-1"><a href="#cb70-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, results)</span></code></pre></div>
</div>
</div>
<div id="frequency-analyses-reptable" class="section level2">
<h2>3. Frequency analyses (repTable)</h2>
<p>Univariate frequency analyses of polytomous variables can be thought
of mean analyses of dichotomous indicator variables.
<code>repTable()</code> would not be necessary then—for example, you can
redefine a 5-level polytomous variable into five dichotomous indicators
and call <code>repMean()</code> five times. The main differences between
frequency and mean analyses is the underlying statistic for group
differences: mean analyses typically uses a <em>t</em> test for
independent samples (e.g., “Differ males and females in their mean
reading competencies?”). Frequency tables, however, use <span class="math inline">\(\chi^2\)</span> tests, for example (“Differ males
and females in their distribution of competence levels?”). In theory,
you can test for each competence level 1, 2, 3, 4, and 5 with a separate
<em>t</em> test, whether males and females differ. The comparisons,
however, are not independent—a Bonferroni correction might be
appropriate then. In the following, both variants are sketched:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="do">### first example: group comparisons with a chi^2-Test: we check for each country </span></span>
<span id="cb71-2"><a href="#cb71-2" tabindex="-1"></a><span class="do">### whether the distribution of competence levels differs between males and females</span></span>
<span id="cb71-3"><a href="#cb71-3" tabindex="-1"></a>freq1 <span class="ot">&lt;-</span> <span class="fu">repTable</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb71-4"><a href="#cb71-4" tabindex="-1"></a>         <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), </span>
<span id="cb71-5"><a href="#cb71-5" tabindex="-1"></a>         <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">cross.differences =</span> <span class="cn">FALSE</span>, <span class="at">dependent =</span> <span class="st">&quot;comp&quot;</span>, </span>
<span id="cb71-6"><a href="#cb71-6" tabindex="-1"></a>         <span class="at">chiSquare =</span> <span class="cn">TRUE</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a>res1  <span class="ot">&lt;-</span> <span class="fu">report2</span>(freq1, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb =</span> <span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>In the second example, the group comparisons are conducted applying
five separate <em>t</em> tests. For each country and each single
competence level, <code>repTable()</code> checks whether the
distribution differs between males and females. Technically,
<code>repMean()</code> is called five times consecutively.</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb74-1"><a href="#cb74-1" tabindex="-1"></a>freq2 <span class="ot">&lt;-</span> <span class="fu">repTable</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb74-2"><a href="#cb74-2" tabindex="-1"></a>         <span class="at">repInd=</span><span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, </span>
<span id="cb74-3"><a href="#cb74-3" tabindex="-1"></a>         <span class="at">cross.differences =</span> <span class="cn">FALSE</span>, <span class="at">dependent =</span> <span class="st">&quot;comp&quot;</span>, <span class="at">chiSquare =</span> <span class="cn">FALSE</span>, <span class="at">progress =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb76"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb76-1"><a href="#cb76-1" tabindex="-1"></a>res2  <span class="ot">&lt;-</span> <span class="fu">report2</span>(freq2, <span class="at">add =</span> <span class="fu">list</span>( <span class="at">kb =</span> <span class="st">&quot;reading&quot;</span>))[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<p>In <code>repTable()</code>, the computation of cross-level
differences and trends works analogously to <code>repMean()</code>.</p>
<div id="looping-across-several-dependent-variables" class="section level3">
<h3>3.1 Looping across several dependent variables</h3>
<p>Section 2.5 demonstrates the use of <code>by()</code> loops to
analyze more than one domain with one single call. The same principle
works for several dependent variables within one domain. Suppose you
have several dichotomous criteria (e.g. “failed to reach minimal
standard”, “pass regular standard”, “pass optimal standard”),
represented by several variables. A <code>lapply()</code> loop ca be
applied then:</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="do">### abhaengige Variablen definieren</span></span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a>DVs   <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;failMin&quot;</span>, <span class="st">&quot;passReg&quot;</span>, <span class="st">&quot;passOpt&quot;</span>)</span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a>freq3 <span class="ot">&lt;-</span> <span class="fu">lapply</span>(DVs, <span class="at">FUN =</span> <span class="cf">function</span> (dv) { </span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a>         <span class="fu">repTable</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a>            <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), </span>
<span id="cb77-6"><a href="#cb77-6" tabindex="-1"></a>            <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">cross.differences =</span> <span class="cn">FALSE</span>, </span>
<span id="cb77-7"><a href="#cb77-7" tabindex="-1"></a>            <span class="at">dependent =</span> dv, <span class="at">progress =</span> <span class="cn">FALSE</span>) })</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<p>The reporting function <code>report()</code> must be called three
times, likewise in a <code>lapply()</code> loop:</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb79-1"><a href="#cb79-1" tabindex="-1"></a>allResults3     <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, <span class="fu">lapply</span>(freq3, report))</span></code></pre></div>
</div>
<div id="nested-loops" class="section level3">
<h3>3.2 Nested loops</h3>
<p>Both types of loops (across non-nested grouping variables and across
several dependent variables) may be combined. In the following example,
we want to analyze three dependent variables for two domains. Hence, a
two-stage loop for <span class="math inline">\(3\times 2=6\)</span>
analyses is necessary:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>DVs   <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;failMin&quot;</span>, <span class="st">&quot;passReg&quot;</span>, <span class="st">&quot;passOpt&quot;</span>)</span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>freq4 <span class="ot">&lt;-</span> <span class="fu">lapply</span>(DVs, <span class="at">FUN =</span> <span class="cf">function</span> (dv) { </span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a>         f4 <span class="ot">&lt;-</span> <span class="fu">by</span> ( <span class="at">data =</span> bt2010, <span class="at">INDICES =</span> bt2010[,<span class="st">&quot;domain&quot;</span>], <span class="at">FUN =</span> <span class="cf">function</span> (sub.dat) {</span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a>               <span class="fu">repTable</span>(<span class="at">datL =</span> sub.dat, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a>                         <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), </span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a>                         <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">cross.differences =</span> <span class="cn">FALSE</span>, </span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a>                         <span class="at">dependent =</span> dv, <span class="at">progress =</span> <span class="cn">FALSE</span>)})})</span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<p>To convert the results in a more user-friendly format:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb82-1"><a href="#cb82-1" tabindex="-1"></a>allResults4  <span class="ot">&lt;-</span> <span class="fu">lapply</span>(freq4, <span class="at">FUN =</span> <span class="cf">function</span> (av) { </span>
<span id="cb82-2"><a href="#cb82-2" tabindex="-1"></a>                       <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, <span class="fu">lapply</span>(<span class="fu">names</span>(av), <span class="at">FUN =</span> <span class="cf">function</span> ( x ) { </span>
<span id="cb82-3"><a href="#cb82-3" tabindex="-1"></a>                         <span class="fu">report2</span>(av[[x]], <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb=</span>x))[[<span class="st">&quot;plain&quot;</span>]]}))})</span>
<span id="cb82-4"><a href="#cb82-4" tabindex="-1"></a>allResults4  <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, allResults4)</span></code></pre></div>
<p>A combination of two loops also works for trend analyses. Please note
that each dependent variable potentially has its own linking error. If
so, one solution is to store the variable name along with its linking
error in a <code>data.frame</code> and use an <code>apply()</code>
loop:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a><span class="do">### two-stage nested loop with trend analysis</span></span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a><span class="do">### first we define the dependent variables (dv) and their linking errors (le)</span></span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a>DVs   <span class="ot">&lt;-</span> <span class="fu">data.frame</span> ( <span class="at">dv =</span> <span class="fu">c</span>(<span class="st">&quot;failMin&quot;</span>, <span class="st">&quot;passReg&quot;</span>, <span class="st">&quot;passOpt&quot;</span>), </span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a>                      <span class="at">le =</span> <span class="fu">c</span>(<span class="st">&quot;leFailMin&quot;</span>, <span class="st">&quot;lePassReg&quot;</span>, <span class="st">&quot;lePassOpt&quot;</span>), </span>
<span id="cb83-5"><a href="#cb83-5" tabindex="-1"></a>                      <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span>)</span>
<span id="cb83-6"><a href="#cb83-6" tabindex="-1"></a>freq5 <span class="ot">&lt;-</span> <span class="fu">apply</span>(DVs, <span class="at">MARGIN =</span> <span class="dv">1</span>, <span class="at">FUN =</span> <span class="cf">function</span> (depVars) { </span>
<span id="cb83-7"><a href="#cb83-7" tabindex="-1"></a>         f4 <span class="ot">&lt;-</span> <span class="fu">by</span> ( <span class="at">data =</span> bt, <span class="at">INDICES =</span> bt[,<span class="st">&quot;domain&quot;</span>], <span class="at">FUN =</span> <span class="cf">function</span> (sub.dat) {</span>
<span id="cb83-8"><a href="#cb83-8" tabindex="-1"></a>               <span class="fu">repTable</span>(<span class="at">datL =</span> sub.dat, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb83-9"><a href="#cb83-9" tabindex="-1"></a>                         <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="fu">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;sex&quot;</span>), </span>
<span id="cb83-10"><a href="#cb83-10" tabindex="-1"></a>                         <span class="at">group.differences.by =</span> <span class="st">&quot;sex&quot;</span>, <span class="at">cross.differences =</span> <span class="cn">FALSE</span>, </span>
<span id="cb83-11"><a href="#cb83-11" tabindex="-1"></a>                         <span class="at">trend =</span> <span class="st">&quot;year&quot;</span>, <span class="at">dependent =</span> depVars[[<span class="st">&quot;dv&quot;</span>]],</span>
<span id="cb83-12"><a href="#cb83-12" tabindex="-1"></a>                         <span class="at">linkErr =</span> depVars[[<span class="st">&quot;le&quot;</span>]], <span class="at">progress =</span> <span class="cn">FALSE</span>)})})</span></code></pre></div>
<pre><code>## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.
##
## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 2&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.</code></pre>
<p>To convert the results in a more user-friendly format:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a>allResults5 <span class="ot">&lt;-</span> <span class="fu">lapply</span>(freq5, <span class="at">FUN =</span> <span class="cf">function</span> (av) { </span>
<span id="cb85-2"><a href="#cb85-2" tabindex="-1"></a>                       <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, <span class="fu">lapply</span>(<span class="fu">names</span>(av), <span class="at">FUN =</span> <span class="cf">function</span> ( x ) { </span>
<span id="cb85-3"><a href="#cb85-3" tabindex="-1"></a>                          <span class="fu">report2</span>(av[[x]], <span class="at">add =</span> <span class="fu">list</span>(<span class="at">kb=</span>x))[[<span class="st">&quot;plain&quot;</span>]]}))})</span></code></pre></div>
<pre><code>## Warning in FUN(X[[i]], ...): Found 6 missing linking errors for dependent variable &#39;failMin&#39; and parameter(s) &#39;NcasesValid&#39;. Assume linking error of 0 for these cases.
## Warning in FUN(X[[i]], ...): Found 6 missing linking errors for dependent variable &#39;passReg&#39; and parameter(s) &#39;NcasesValid&#39;. Assume linking error of 0 for these cases.
## Warning in FUN(X[[i]], ...): Found 6 missing linking errors for dependent variable &#39;passOpt&#39; and parameter(s) &#39;NcasesValid&#39;. Assume linking error of 0 for these cases.</code></pre>
<div class="sourceCode" id="cb87"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb87-1"><a href="#cb87-1" tabindex="-1"></a>allResults5 <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, allResults5)</span></code></pre></div>
</div>
</div>
<div id="analyses-of-ranges-repquantile" class="section level2">
<h2>4. Analyses of ranges (repQuantile)</h2>
<p>When analyzing quartiles, quantiles or percentiles, please note that
the computation of group differences is not supported yet.
<code>repQuantile</code> requires to specify the probabilities via the
<code>probs</code> argument. The following example illustrates the usage
of the function for the domain “reading” for 2010 and 2015. We compute
the 5., 10., 25., 75., 90., and 95. percentile:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a>btRead <span class="ot">&lt;-</span> bt[<span class="fu">which</span>(bt[,<span class="st">&quot;domain&quot;</span>] <span class="sc">==</span> <span class="st">&quot;reading&quot;</span>),]</span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a>quan   <span class="ot">&lt;-</span> <span class="fu">repQuantile</span>(<span class="at">datL =</span> btRead, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb88-3"><a href="#cb88-3" tabindex="-1"></a>               <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="st">&quot;country&quot;</span>, <span class="at">trend =</span> <span class="st">&quot;year&quot;</span>, </span>
<span id="cb88-4"><a href="#cb88-4" tabindex="-1"></a>               <span class="at">dependent =</span> <span class="st">&quot;score&quot;</span>, <span class="at">linkErr =</span> <span class="st">&quot;leScore&quot;</span>, </span>
<span id="cb88-5"><a href="#cb88-5" tabindex="-1"></a>               <span class="at">probs =</span> <span class="fu">c</span>(.<span class="dv">05</span>, .<span class="dv">1</span>, .<span class="dv">25</span>, .<span class="dv">75</span>, .<span class="dv">90</span>, .<span class="dv">95</span>), <span class="at">progress =</span> <span class="cn">FALSE</span> )</span></code></pre></div>
<pre><code>## 
## Trend group: &#39;2010&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.
## 
## 
## Trend group: &#39;2015&#39;
## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 73 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a>res    <span class="ot">&lt;-</span> <span class="fu">report</span>(quan, <span class="at">add =</span> <span class="fu">list</span>(<span class="at">domain =</span> <span class="st">&quot;reading&quot;</span>))</span></code></pre></div>
</div>
<div id="regression-analyses-repglm" class="section level2">
<h2>5. Regression analyses (repGlm)</h2>
<p><code>repGlm</code> allows to estimate linear and logistic regression
models. To date, trend analyses do not incorporate linking errors. The
reporting function <code>report()</code> optionally allows to print the
results to the console (if <code>printGlm</code> is set to
<code>TRUE</code>). In the first example, the regression of reading
competence on sex, SES is estimated in each country separately. For a
valid interpretation of interaction effects, SES variable is
standardized within each imputation:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" tabindex="-1"></a>bt2010read <span class="ot">&lt;-</span> <span class="fu">by</span>(<span class="at">data=</span>bt2010read, <span class="at">INDICES =</span> bt2010read[,<span class="st">&quot;imp&quot;</span>], <span class="at">FUN =</span> <span class="cf">function</span> ( i ) { </span>
<span id="cb91-2"><a href="#cb91-2" tabindex="-1"></a>                i[,<span class="st">&quot;ses_std&quot;</span>] <span class="ot">&lt;-</span> <span class="fu">scale</span>(i[,<span class="st">&quot;ses&quot;</span>])[,<span class="dv">1</span>]</span>
<span id="cb91-3"><a href="#cb91-3" tabindex="-1"></a>                <span class="fu">return</span>(i)})</span>
<span id="cb91-4"><a href="#cb91-4" tabindex="-1"></a>bt2010read <span class="ot">&lt;-</span> <span class="fu">do.call</span>(<span class="st">&quot;rbind&quot;</span>, bt2010read)              </span>
<span id="cb91-5"><a href="#cb91-5" tabindex="-1"></a>reg1   <span class="ot">&lt;-</span> <span class="fu">repGlm</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb91-6"><a href="#cb91-6" tabindex="-1"></a>               <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">groups =</span> <span class="st">&quot;country&quot;</span>,  <span class="at">formula =</span> score<span class="sc">~</span>sex<span class="sc">*</span>ses_std, </span>
<span id="cb91-7"><a href="#cb91-7" tabindex="-1"></a>               <span class="at">family=</span><span class="fu">gaussian</span>(<span class="at">link=</span><span class="st">&quot;identity&quot;</span>), <span class="at">progress =</span> <span class="cn">FALSE</span>) </span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 1&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" tabindex="-1"></a>res1   <span class="ot">&lt;-</span> <span class="fu">report2</span>(reg1, <span class="at">add =</span> <span class="fu">list</span>(<span class="at">domain =</span> <span class="st">&quot;reading&quot;</span>), <span class="at">printGlm =</span> <span class="cn">TRUE</span>)[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<pre><code>##        Trend group: &#39;noTrend&#39;.
##             groups: type = point; country = countryA; row = 1; id = 14574361_1
##             domain: reading
## dependent Variable: score
##  
##         parameter     est    se t.value p.value sig
## 1     (Intercept) 505.837 4.428 114.243   0.000 ***
## 2         ses_std  23.697 3.876   6.114   0.000 ***
## 3         sexmale   8.677 5.594   1.551   0.121    
## 4 sexmale:ses_std   4.109 5.527   0.743   0.457    
## 
##             R-squared: 0.115; SE(R-squared): NA
## 1034 observations and 1030 degrees of freedom.
## ------------------------------------------------------------------
##             groups: type = point; country = countryB; row = 4; id = 14574361_4
##             domain: reading
## dependent Variable: score
##  
##         parameter     est    se t.value p.value sig
## 1     (Intercept) 499.044 4.624 107.934   0.000 ***
## 2         ses_std  28.344 4.637   6.113   0.000 ***
## 3         sexmale   7.918 7.804   1.015   0.311    
## 4 sexmale:ses_std   7.598 5.024   1.512   0.131    
## 
##             R-squared: 0.181; SE(R-squared): NA
## 959 observations and 955 degrees of freedom.
## ------------------------------------------------------------------
##             groups: type = point; country = countryC; row = 7; id = 14574361_7
##             domain: reading
## dependent Variable: score
##  
##         parameter     est    se t.value p.value sig
## 1     (Intercept) 525.240 3.788 138.663   0.000 ***
## 2         ses_std  24.083 5.246   4.591   0.000 ***
## 3         sexmale  15.108 5.289   2.856   0.004  **
## 4 sexmale:ses_std   0.879 7.460   0.118   0.906    
## 
##             R-squared: 0.096; SE(R-squared): NA
## 1086 observations and 1082 degrees of freedom.</code></pre>
<p>The second example illustrates a logistic regression. Whether or not
the regular standard was passed (<code>passReg</code>) is the dependent
variable. The variable <code>country</code> is now used as a
predictor.</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" tabindex="-1"></a>reg2   <span class="ot">&lt;-</span> <span class="fu">repGlm</span>(<span class="at">datL =</span> bt2010read, <span class="at">ID=</span><span class="st">&quot;idstud&quot;</span>, <span class="at">wgt=</span><span class="st">&quot;wgt&quot;</span>, <span class="at">type=</span><span class="st">&quot;jk2&quot;</span>, <span class="at">PSU=</span><span class="st">&quot;jkzone&quot;</span>, </span>
<span id="cb95-2"><a href="#cb95-2" tabindex="-1"></a>               <span class="at">repInd =</span> <span class="st">&quot;jkrep&quot;</span>, <span class="at">imp=</span><span class="st">&quot;imp&quot;</span>, <span class="at">formula =</span> passReg<span class="sc">~</span>country<span class="sc">*</span>ses_std, </span>
<span id="cb95-3"><a href="#cb95-3" tabindex="-1"></a>               <span class="at">family=</span><span class="fu">binomial</span>(<span class="at">link=</span><span class="st">&quot;logit&quot;</span>), <span class="at">progress =</span> <span class="cn">FALSE</span>) </span></code></pre></div>
<pre><code>## 1 analyse(s) overall according to: &#39;group.splits = 0&#39;.
## Assume unnested structure with 3 imputations.
## Create 92 replicate weights according to JK2 procedure.</code></pre>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" tabindex="-1"></a>res2   <span class="ot">&lt;-</span> <span class="fu">report2</span>(reg2, <span class="at">add =</span> <span class="fu">list</span>(<span class="at">domain =</span> <span class="st">&quot;reading&quot;</span>), <span class="at">printGlm =</span> <span class="cn">TRUE</span>)[[<span class="st">&quot;plain&quot;</span>]]</span></code></pre></div>
<pre><code>##        Trend group: &#39;noTrend&#39;.
##             groups: type = point; row = 1; id = 14575099_1
##             domain: reading
## dependent Variable: passReg
##  
##                 parameter    est    se t.value p.value sig
## 1             (Intercept) -0.227 0.115  -1.972   0.049   *
## 2         countrycountryB -0.206 0.156  -1.317   0.188    
## 3 countrycountryB:ses_std  0.097 0.159   0.613   0.540    
## 4         countrycountryC  0.465 0.141   3.305   0.001 ***
## 5 countrycountryC:ses_std -0.086 0.142  -0.604   0.546    
## 6                 ses_std  0.609 0.082   7.401   0.000 ***
## 
##             R-squared: 0.116; SE(R-squared): NA
## 3079 observations and 3073 degrees of freedom.</code></pre>
<p>The output gives the <span class="math inline">\(R^2\)</span> (for
linear regression models) as well as Nagelkerke’s <span class="math inline">\(R^2\)</span> (for logistic regression models).</p>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0" line-spacing="2">
<div id="ref-RN3" class="csl-entry">
Foy, P., Galia, J., &amp; Li, I. (2008). Scaling the data from the TIMSS
2007 mathematics and science asssessment [Book Section]. In J. F. Olson,
M. O. Martin, &amp; I. V. S. Mullis (Eds.), <em>TIMSS 2007 technical
report</em> (pp. 225–280). TIMSS &amp; PIRLS International Study Center,
Lynch School of Education, Boston College.
</div>
<div id="ref-RN416" class="csl-entry">
Grotenhuis, M. te, Pelzer, B., Eisinga, R., Nieuwenhuis, R.,
Schmidt-Catran, A., &amp; Konig, R. (2017). When size matters:
Advantages of weighted effect coding in observational studies [Journal
Article]. <em>International Journal of Public Health</em>, <em>62</em>,
163–167.
</div>
<div id="ref-RN487" class="csl-entry">
Krewski, D., &amp; Rao, J. N. K. (1981). Inference from stratified
samples: Properties of the linearization, jackknife and balanced
repeated replication method [Journal Article]. <em>Annals of
Statistics</em>, <em>9</em>, 1010–1019.
</div>
<div id="ref-RN164" class="csl-entry">
Little, R. J. A., &amp; Rubin, D. B. (1987). <em>Statistical analyses
with missing data</em> [Book]. Wiley.
</div>
<div id="ref-RN477" class="csl-entry">
Mayer, A., Dietzfelbinger, L., Rosseel, Y., &amp; Steyer, R. (2016). The
EffectLiteR approach for analyzing average and conditional effects
[Journal Article]. <em>Multivariate Behavioral Research</em>,
<em>51</em>, 374–391.
</div>
<div id="ref-RN523" class="csl-entry">
Nachtigall, C., Kröhne, U., Enders, U., &amp; Steyer, R. (2008). Causal
effects and fair comparisons: Considering the influence of context
variables on student competencies [Book Section]. In J. Hartig, E.
Klieme, &amp; D. Leutner (Eds.), <em>Assessment of competencies in
educational contexts</em>. Hogrefe &amp; Huber.
</div>
<div id="ref-RN77" class="csl-entry">
Rubin, D. B. (2003). Nested multiple imputation of NMES via partially
incompatible MCMC [Journal Article]. <em>Statistica Neerlandica</em>,
<em>57</em>(1), 3–18.
</div>
<div id="ref-RN421" class="csl-entry">
Rust, K. (2014). Sampling, weighting, and variance estimation [Book
Section]. In L. Rutkowski, M. Von Davier, &amp; D. Rutkowski (Eds.),
<em>Handbook of international large-scale assessment</em>. CRC Press.
</div>
<div id="ref-RN393" class="csl-entry">
Rust, K., &amp; Rao, J. N. K. (1996). Variance estimation for complex
surveys using replication techniques [Journal Article]. <em>Statistical
Methods in Medical Research</em>, <em>5</em>, 283–310.
</div>
<div id="ref-RN557" class="csl-entry">
Weirich, S., Hecht, M., Becker, B., &amp; Zitzmann, S. (2021). Comparing
group means with the total mean in random samples, surveys, and
large-scale assessments: A tutorial and software illustration [Journal
Article]. <em>Behavior Research Methods</em>, 1–12. https://doi.org/<a href="https://doi.org/10.3758/s13428-021-01553-1">https://doi.org/10.3758/s13428-021-01553-1</a>
</div>
<div id="ref-RN603" class="csl-entry">
Wolter, K. M. (2007). <em>Introduction to variance estimation</em>
[Book]. Springer.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
